# 스프링 CRUD 게시판 스터디 보고서 (2025-12-11)

### 현재 프로젝트 상태

- Repository URL: [GitHub](https://github.com/BPdog/board_advanced-board/tree/e4ad2da09fb0149ffa3813bc123823273b3510af)

## 오늘 완료한 작업

### 1. Service 계층에서 다른 도메인 Repository 참조 문제 해결

- PostService, BoardService에서 다른 도메인의 Repository를 직접 주입/호출하던 코드를 제거하고, 각 도메인의 Service를 통해 협력하도록 리팩토링 진행.
- CommentService, PostService에 도메인별 헬퍼 메서드를 추가하여, 다른 계층/도메인에서 필요한 조회 기능을 서비스 메서드로 캡슐화.
- Service → Service 간 협력을 통해, Service → 다른 도메인 Repository 직접 의존 구조를 제거하여 계층 구조(Controller → Service → Repository)를 준수하도록 개선.

예시 정리:

- User 조회: Repository 직접 접근 → UserService의 `findByEmail`, `findByUsername` 사용.
- Board 조회: Repository 직접 접근 → BoardService의 `findByName` 사용.
- Comment, Post 관련 조회: CommentService, PostService 내부 헬퍼 메서드에서 캡슐화.

---

### 2. Optional 도입 및 RESTful URL 개선

- 결과가 없을 수 있는 “검색/조회” 기능에 `Optional`을 도입하고, 메서드명/URL 구조를 함께 개선.

변경 사항:

- Service 메서드
  - `UserService.getUserByEmail` → `findByEmail` (반환 타입: `Optional<User>`)
  - `UserService.getUserByUsername` → `findByUsername` (반환 타입: `Optional<User>`)
  - `BoardService.getBoardByName` → `findByName` (반환 타입: `Optional<Board>`)
- RESTful URL
  - `/api/users/email` → `/api/users/search/email`
  - `/api/users/username` → `/api/users/search/username`
  - `/api/boards/name` → `/api/boards/search/name`
- Controller에서 Optional 처리
  - `optional.map(ResponseEntity::ok).orElse(ResponseEntity.notFound().build())` 패턴으로 200/404 응답을 명확히 분기.

도입 이유:

- 검색/조회 결과가 없을 수 있음을 타입 수준에서 명확히 표현.
- null 체크 대신 Optional을 사용해 의도를 드러내고 NPE 위험 감소.
- ID 기반 필수 조회는 예외를 유지하고, 검색 성격의 조회는 Optional로 분리하여 정책을 명확하게 구분.

---

### 3. Mockito @Mock / @InjectMocks, verify 정리

- 테스트 코드에서 `@Mock`과 `@InjectMocks`의 역할과 차이를 정리.

정리 내용:

- `@Mock`
  - Repository, 외부 서비스 등 “의존성”에 대한 가짜 객체 생성.
  - 실제 로직은 수행하지 않고, `when(...).thenReturn(...)`으로 동작 정의.
- `@InjectMocks`
  - 실제로 테스트할 Service 인스턴스 생성.
  - 해당 Service에 `@Mock`으로 생성한 의존성들을 자동 주입.
- `verify()`
  - 특정 Mock 메서드가 호출되었는지/몇 번 호출되었는지 검증.
  - 대표적인 사용:
    - `verify(repo, times(1)).save(any())`
    - `verify(service, never()).deleteUser(any())`
    - `verify(service, atLeastOnce()).findByEmail(any())`

테스트 관점에서 정리:

- 반환값 검증: `assertEquals`, `assertTrue` 등으로 결과 값 검증.
- 행위 검증: `verify()`로 “어떤 메서드가 어떻게 호출되었는지”까지 함께 확인하여, 비즈니스 로직이 의도대로 동작하는지 보장.

[Mock & InjectMocks 정리](https://www.notion.so/yoing-/mock-InjectMocks-2c0f867dc004809fad55e87076b31447?source=copy_link)
[verify() 정리](https://www.notion.so/yoing-/Mock-verify-2c0f867dc0048040a93bf9b4183ec8c1?source=copy_link)

### 4. Spring Security Controller 학습 정리

Spring Security가 적용된 Controller 흐름을 정리하고, 인증/인가 처리와 컨트롤러 매핑 관계를 학습.

인증된 사용자 정보(SecurityContext)에서 Principal을 꺼내 사용하는 방법과, 권한별 접근 제어(@PreAuthorize, URL 패턴 기반 권한 설정 등)를 정리.

관련 내용은 별도 문서에 정리:
[Spring Security Controller 정리](https://www.notion.so/yoing-/Spring-Security-Controller-2c6f867dc0048089b3d9e05e7925e6a5)

---

## 피드백 및 논의 사항

### 1. Gradle, Spring Boot, Hibernate 버전 및 설정 이슈

- Gradle 버전과 Spring Boot 버전 간 호환성 문제로 인해 빌드 오류 발생.
- Spring Boot 3.x 사용 시 JDK 17 이상 필요, Hibernate 버전도 이에 맞춰 자동 설정되므로:
  - JDK, Spring Boot, Gradle 버전 매트릭스를 먼저 확인해야 함.
- `application.properties`에서 Hibernate 관련 프로퍼티 설정 시:
  - `spring.jpa.database-platform`, `spring.jpa.hibernate.ddl-auto`, `use_jdbc_metadata_defaults` 등 설정 값을 사용하는 DB/버전에 맞게 정확히 지정해야 함.

### [해결책]

- 사용 중인 JDK 버전에 맞는 Spring Boot 버전으로 조정.
- Spring Initializr 또는 공식 문서에서 권장하는 Gradle/Boot/JDK 조합을 기준으로 프로젝트 설정 재점검.
- Hibernate 관련 프로퍼티는 DB 버전(MySQL 8 등)에 맞는 Dialect로 명시하고, 필요 이상 설정은 줄여 문제 원인 범위를 축소.
- 버전 관련 이슈가 발생하면:
  1. 현재 JDK 버전 확인
  2. Spring Boot 공식 문서에서 해당 버전이 지원하는 JDK/Gradle 범위 확인
  3. Gradle Wrapper와 `build.gradle`의 플러그인/의존성 버전 동기화

---

## 다음에 할 일

- user를 제외한 다른 엔티티(Board, Post, Comment 등)의 Service, Controller 테스트 코드 작성.
- Service 간 협력 구조(도메인별 Service 호출)를 현재 프로젝트 전체 코드에 일관되게 적용하고, 남은 Repository 직접 참조 코드 제거.
- Optional 기반 조회/검색 패턴을 다른 엔티티, API에도 확장 적용하여 조회 정책을 통일.
- Mockito 테스트 코드에서 verify, ArgumentCaptor 등을 활용해 행위 검증을 강화하고, Service 리팩토링 이후 테스트 케이스 보완.
